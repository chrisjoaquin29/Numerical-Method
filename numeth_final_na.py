# -*- coding: utf-8 -*-
"""Numeth_final_na.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1KOBsIzrAbfG6zTBUgkhgutG6MTZ6Lyxv
"""

import numpy as np
import matplotlib.pyplot as plt

#For single root.
def b_force(f,h):
  epochs = 100
  x_roots = []
  for epoch in range(epochs):
    x_guess = f(h)
    print(x_guess)
    if x_guess == 0:
      x_roots.append(h)
      break
    else:
         h+=1
  return print(f"The root is: {x_roots}, found at epoch {epoch}")

# Finding n number of roots.
def brute_nforce(f,h):
  epochs = 100
  n_roots = 3
  x_roots = []
  end_epoch = 0
  for epoch in range(epochs):
    print(f(h))
    if np.allclose(0,f(h)):
      x_roots.append(h)
      end_epoch = epoch
      if len(x_roots)==n_roots:
        break
    h+=1
  return print(f"The roots are: {x_roots}, found at epoch {end_epoch+1}")

"""### Newton  Method"""

## Single Root
def newt_R(f,f_prime):
  epochs = 100
  x = 0
  root = 0
  for epoch in range(epochs):
    x_prime = x - (f(x)/f_prime(x))
    if np.allclose(x, x_prime):
      root = x
      break
    x = x_prime
  return print(f"The root is: {root}, found at epoch {epoch}")

# Findng n number of  roots 
def newt_N(f,f_prime):
  epochs = 100
  x_inits = np.arange(0,5)
  roots = []
  for x_init in x_inits:
    print("Iteration Number: ", x_init)
    x = x_init
    print("x is: ", x)
    for epoch in range(epochs):
      print("Epoch: ", epoch)
      x_prime = x - (f(x)/f_prime(x))
      print("x prime is: ", x_prime)
      if np.allclose(x, x_prime):
        roots.append(x)
        print("roots: ", roots)
        break
      x = x_prime
      print("x final: ", x)
    
  print("np_roots before round: ",roots)
  np_roots = np.round(roots,3)
  print("np_roots after round: ", np_roots)
  np_roots = np.unique(np_roots)
  print("np_roots after sorting to unique: ", np_roots)
  return np_roots

"""### Bisection method"""

def bisec(i1,i2):
  y1, y2 = f(i1), f(i2)
  root = []
  end_bisect = 0
  if np.sign(y1) == np.sign(y2):
    print("Root cannot be found in the given interval")
  else:
    for bisect in range(0,100):
      midp = np.mean([i1,i2])
      y_mid = f(midp)
      y1 = f(i1)
      if np.allclose(0,y1, 1e-06):
        root.append(i1)
        end_bisect = bisect
        break
      if np.sign(y1) != np.sign(y_mid): #root is in first-half interval
        i2 = midp
      else: #root is in second-half interval
        i1 = midp 

  print("The root is {}, found at {} bisections".format(root, end_bisect))

"""### Regula Falsi Method"""

def f(x): return 2*x**2 - 5*x + 3

def falsi(X,x):
  y1 = f(X) 
  y2 = f(x)
  root = []
  pos = 0
  if np.allclose(0,y1): root = X
  elif np.allclose(0,y2): root = x
  elif np.sign(y1) == np.sign(y2):
    print("No root here")
  else:
    for pos in range(0,100):
      c = x - (f(x)*(x-X))/(f(x)-f(X)) ##false root
      if np.allclose(0,f(c), 1e-06):
        root.append(c)
        break
      if np.sign(f(X)) != np.sign(f(c)): x,y2 = c,f(c)
      else: X,y1 = c,f(c) 

  print("The root is {}, found at {} false position".format(root, pos))

"""### Secant Method """

def sec(a,b):
  epochs = 100
  root = []
  end_epoch = 0
  for epoch in range(epochs):
    c = b - (f(b)*(b-a))/(f(b)-f(a))
    if np.allclose(b,c): 
      root.append(c)
      end_epoch = epoch
      break
    else:
      a,b = b,c
  print("The root is {}, found at {} epochs".format(root, end_epoch))